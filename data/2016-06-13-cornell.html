<!doctype html>
<html lang="en">
<head>
<title>2016-06-13-cornell</title>
<meta name="generator" content="Etherpad">
<meta name="author" content="Etherpad">
<meta name="changedby" content="Etherpad">
<meta charset="utf-8">
<style> * { font-family: arial, sans-serif;
font-size: 13px;
line-height: 17px; }ul.indent { list-style-type: none; }ol { list-style-type: none; padding-left:0;}body > ol { counter-reset: first second third fourth fifth sixth seventh eigth ninth tenth eleventh twelth thirteenth fourteenth fifteenth sixteenth; }ol > li:before {content: counter(first) ". " ;counter-increment: first;}ol > ol > li:before {content: counter(first) "." counter(second) ". " ;counter-increment: second;}ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) ". ";counter-increment: third;}ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) ". ";counter-increment: fourth;}ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) ". ";counter-increment: fifth;}ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) ". ";counter-increment: sixth;}ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) ". ";counter-increment: seventh;}ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) ". ";counter-increment: eigth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) ". ";counter-increment: ninth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) ". ";counter-increment: tenth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) ". ";counter-increment: eleventh;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) ". ";counter-increment: twelth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) ". ";counter-increment: thirteenth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) ". ";counter-increment: fourteenth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "."  counter(eigth) "."  counter(ninth) "."  counter(tenth) "."  counter(eleventh) "."  counter(twelth) "."  counter(thirteenth) "."  counter(fourteenth) "." counter(fifteenth) ". ";counter-increment: fifteenth;}ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "."  counter(eigth) "."  counter(ninth) "."  counter(tenth) "."  counter(eleventh) "."  counter(twelth) "."  counter(thirteenth) "."  counter(fourteenth) "."  counter(fifteenth) "."  counter(sixthteenth) ". ";counter-increment: sixthteenth;}ol{ text-indent: 0px; }ol > ol{ text-indent: 10px; }ol > ol > ol{ text-indent: 20px; }ol > ol > ol > ol{ text-indent: 30px; }ol > ol > ol > ol > ol{ text-indent: 40px; }ol > ol > ol > ol > ol > ol{ text-indent: 50px; }ol > ol > ol > ol > ol > ol > ol{ text-indent: 60px; }ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 70px; }ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 80px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 90px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 100px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 110px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol { text-indent: 120px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 130px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 140px; }ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol{ text-indent: 150px; }</style>
</head>
<body><strong>Welcome to the CSCU 2016 Data Carpentry Workshop!</strong><br>June 13-14, 2016<br><br><strong>Instructors:</strong><br><ul class="bullet"><li>&nbsp;&nbsp;&nbsp; Erika Mudrak</li><li>&nbsp;&nbsp;&nbsp; Lynn Johnson</li><li>&nbsp;&nbsp;&nbsp; Emily Davenport</li></ul>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>Helpers:</strong><br><ul class="bullet"><li>&nbsp;&nbsp;&nbsp; Francoise Vermeylen</li><li>&nbsp;&nbsp;&nbsp; Stephen Parry</li><li>&nbsp;&nbsp;&nbsp; Kevin Packard</li><li>&nbsp;&nbsp;&nbsp; David Kent</li></ul><br><strong>Helpful links:</strong><br><ul class="bullet"><li>&nbsp;&nbsp;&nbsp; Website: <a href="http&#x3a;&#x2F;&#x2F;erdavenport&#x2e;github&#x2e;io&#x2F;2016&#x2d;06&#x2d;13&#x2d;cornell&#x2F;">http:&#x2F;&#x2F;erdavenport.github.io&#x2F;2016-06-13-cornell&#x2F;</a></li><li>&nbsp;&nbsp;&nbsp; R lesson material: <a href="http&#x3a;&#x2F;&#x2F;erdavenport&#x2e;github&#x2e;io&#x2F;R&#x2d;ecology&#x2d;lesson&#x2F;">http:&#x2F;&#x2F;erdavenport.github.io&#x2F;R-ecology-lesson&#x2F;</a></li><li>&nbsp;&nbsp;&nbsp; R data: <a href="http&#x3a;&#x2F;&#x2F;dx&#x2e;doi&#x2e;org&#x2F;10&#x2e;6084&#x2F;m9&#x2e;figshare&#x2e;1314459">http:&#x2F;&#x2F;dx.doi.org&#x2F;10.6084&#x2F;m9.figshare.1314459</a></li><li>&nbsp;&nbsp;&nbsp; ggplot2 cheat sheet: <a href="https&#x3a;&#x2F;&#x2F;www&#x2e;rstudio&#x2e;com&#x2F;wp&#x2d;content&#x2F;uploads&#x2F;2015&#x2F;03&#x2F;ggplot2&#x2d;cheatsheet&#x2e;pdf">https:&#x2F;&#x2F;www.rstudio.com&#x2F;wp-content&#x2F;uploads&#x2F;2015&#x2F;03&#x2F;ggplot2-cheatsheet.pdf</a></li><li>&nbsp;&nbsp;&nbsp; dplyr cheat sheet: <a href="https&#x3a;&#x2F;&#x2F;www&#x2e;rstudio&#x2e;com&#x2F;wp&#x2d;content&#x2F;uploads&#x2F;2015&#x2F;02&#x2F;data&#x2d;wrangling&#x2d;cheatsheet&#x2e;pdf">https:&#x2F;&#x2F;www.rstudio.com&#x2F;wp-content&#x2F;uploads&#x2F;2015&#x2F;02&#x2F;data-wrangling-cheatsheet.pdf</a></li></ul><br><strong>Monday Morning Notes:</strong><br>How can we do reproducible science?<br><ul class="indent"><li>- For each step in the process (data cleaning, data summarizing, analysis, figure generation, etc), create a separate script. Future you will appreciate it!</li><li>- Another benefit: if you update your raw data, you should be able to use the same scripts to update your results.&nbsp;</li><li><br></li></ul>So what are we doing in this workshop?<br><ul class="indent"><li>1. Raw data - Excel (Monday morning)</li><li>2. Data cleaning - OpenRefine (Monday morning)</li><li>3. Sumamrizing - R dplyr, ggplot2, SQL databases (Monday afternoon&#x2F;Tuesday morning)</li><li>4. Analysis - R loops and functions (Tuesday afternoon)</li><li>5. Results formatting - R Markdown (Tuesday afternoon)</li><li><br></li></ul>Excel:<br><ul class="indent"><li>Cardinal Rules for spreadsheets:</li><ul class="bullet"><li>Put all your variables in columns</li><li>Put all your observations in it&#x27;s own row</li><li>Don&#x27;t combine info into one cell</li><li>Leave raw data alone!</li></ul><li>Other things to consider:</li><ul class="bullet"><li>What value to use for missing values? (NA, null, N&#x2F;A?) Consider the downstream application you might open it in (R, SQL, etc)</li><li>Column names: only alpha&#x2F;numeric, avoid spaces in names, have the names be understandable, don&#x27;t start with a number</li><li>Place comments in their own column, don&#x27;t use highlighting - it won&#x27;t transfer to stats programs!</li><li>Read the paper on Tidy Data by Hadley Wickham (we&#x27;ll send it out after the workshop)</li><li>What do we do with units? Keep a separate spreadsheet or file that lists more info about each of the columns, including units and a description of what the data is</li><li>Dates - arrrrg!</li><ul class="bullet"><li>Excel doesn&#x27;t actually store dates as you might think: It stores it as the number of days past some date in the past. This changes with versions of excel! See, arrrrg!</li><li>So, what to do?&nbsp;</li><ul class="bullet"><li>Create a separate column, in that cell you can type `=MONTH()` and reference the full date. This will pull just the month from the original date column. Can also do this with `=DAY()` and `=YEAR()`.&nbsp;&nbsp;</li><li>OR you can use a Julian date (1-365, see point below for how) column and a year column</li><li>=A3-DATE(YEAR(A3), 1, 0)...where A3 is the cell you&#x27;re transforming</li></ul></ul><li>Data validation - in the &#x27;Data&#x27; tab, you can set limits or rules for when you&#x27;re entering data. Helps you catch typos or values that are way outside of what you might expect to see. If you enter something that doesn&#x27;t fit with your rules, an error message will pop up.&nbsp;</li><li>Another trick is to sort your data. Often wrong data will sort to the top or bottom of a column.&nbsp;</li><li>You can also use conditional formatting to color cells by their values. This is NOT retained if you export to R or SASS, but can help you clean the data.&nbsp;</li><li>How to save your data: proprietary formats can change or be discontinued. Try to save your data in a plain text format, either .csv or tab delimited by going to &#x27;Save As&quot; and choosing .csv or text (Tab delimited text). When you do this, coloring, fonts, column sizes will go away. The only thing that will stay is the text itself. This is why we don&#x27;t want to use highlighting to note important information.</li></ul></ul><br>OpenRefine:<br><ul><ul class="bullet"><li>Open up the program</li><li>If you need to, use a browser to navigate to <a href="http&#x3a;&#x2F;&#x2F;127&#x2e;0&#x2e;0&#x2e;1&#x3a;3333&#x2F;">http:&#x2F;&#x2F;127.0.0.1:3333&#x2F;</a></li><li>Download the data somewhere on your computer you&#x27;ll be able to find it: <a href="https&#x3a;&#x2F;&#x2F;www&#x2e;dropbox&#x2e;com&#x2F;s&#x2F;kbb4k00eanm19lg&#x2F;Portalrodents19772002&#x5f;scinameUUIDs&#x2e;csv&#x3f;dl&#x3d;0">https:&#x2F;&#x2F;www.dropbox.com&#x2F;s&#x2F;kbb4k00eanm19lg&#x2F;Portalrodents19772002_scinameUUIDs.csv?dl=0</a></li><li>Open up that file using OpenRefine</li><li>Text facets allow you to mass edit entries in your table (for example, change names, fix typos, strip extra spaces, etc.)</li><li>Next to scientificName you&#x27;ll see the arrow, click on that -&gt; &#x27;Facet&#x27; -&gt; &quot;Text Facet&quot;</li><li>You can see a summary of what&#x27;s in that column</li><li>If you click on &#x27;cluster&#x27; in the upper right hand corner of that facet box, you can see you have tools that will try to be smart and cluster things that look very similar together. You can play with the type of clustering (for instance, try method &quot;nearest neighbor&quot; in that menu)</li><li>You can also edit individual cells&nbsp;</li><li>Text facet by column &quot;country&quot;. You can batch edit in that facet. For instance, next to the 15 instances of &#x27;US&#x27;, hit edit, and we can change those all to &quot;UNITED STATES&quot;</li><li>You could also change &quot;HT&quot; to &quot;Haiti&quot; to be more clear.&nbsp;</li><li>You can also split a column into two by clicking the column name -&gt; &quot;Edit Column&quot; -&gt; &quot;Split into two columns&quot; (uncheck remove original column)</li><li>These were all text facets</li><li>You can also do numeric facets. In the facet, you&#x27;ll see a histogram of the numeric values. You can drag that window in the histogram and filter out anything outside of the range you specify</li><li>Can also create scatterplot facets to compare two variables to each other. Can go in just like the histogram and choose which values you want to examine.</li><li>You can do facets on top of facets: so if you filter by a value of a variable, you can then sort using a text facet to sort by a species name, for example.&nbsp;</li><li>Open refine tracks all of the changes you make! This is MUCH nicer than doing it by hand if you were editing in excel.&nbsp;</li><li>You can save these steps by going to the &quot;Undo&#x2F;Redo&quot; button -&gt; click &quot;Extract&quot; , this will save a JSON file of all these steps.&nbsp;</li><li>Now, if you want to do the same steps on another notebook with very similar data, you can go to &quot;Undo&#x2F;Redo&quot; -&gt; click &quot;Apply&quot; and paste that JSON code here.&nbsp;</li><li>To save everything after processing, hit &quot;export&quot; at the very top of the page. You can save it as a csv or tab delimited</li><li>Q: What if you have private data? No worries, this is run using a browser but is not online. It&#x27;s only on your computer and everything is totally private.&nbsp;</li></ul></ul><br><strong>Monday Afternoon Notes:</strong><br><br>Get your project set up:<br><ul class="bullet"><li>Open up RStudio and make a script file &quot;File&quot; -&gt; &quot;New File&quot; -&gt; &quot;R script&quot;</li><li>You can add comments to your scripts using #</li><li>Go to File -&gt; &quot;Save As&quot;, new Folder, &quot;R Session 2&quot;, save text file as Rcode.R</li><li>Now download the data again: <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;datacarpentry&#x2F;ecology&#x2d;workshop&#x2F;blob&#x2F;master&#x2F;data&#x2e;md">https:&#x2F;&#x2F;github.com&#x2F;datacarpentry&#x2F;ecology-workshop&#x2F;blob&#x2F;master&#x2F;data.md</a> and save it to that same &quot;R Session 2&quot; folder where we saved the .R file.</li><li>What is an R project? It&#x27;s a handy way to store your data, scripts, and results in one place.&nbsp;</li><li>&quot;File&quot; -&gt; &quot;New Project&quot; -&gt; &quot;Existing Directory&quot;</li></ul><br>Here&#x27;s the code that Lynn is typing:<br><br>svydat &lt;- read.csv(&quot;surveys.csv&quot;, header=TRUE) # Loads our data into R<br><br># Some useful commands for looking at your data: ----------------------------------<br>head(svydat) # Look at the top few rows of your table<br>dim(svydat) # How many rows and columns are in your table<br>nrow(svydat) # How many rows?<br>ncol(svydat) # How many columns?<br>str(svydat) # useful function that will tell you the type of variable for each column in your dataset, the first few entries in each column,&nbsp;<br><br># Important note: Always check that R is recognizing the variables the way you want it to! Are numbers numeric? Are grouping variables factors? Are descriptions characters?<br><br># Subsetting the data: ---------------------------------------<br># use brackets to subset [rows, columns]<br>svydat[1:10, 1:4] # displays the first ten rows of the first four columns<br>svydat[1:10,c(&quot;record_id&quot;, &quot;plot_id&quot;, &quot;species_id&quot;)] # can also include which columns to pull by naming them<br>svydat$sex # If we only want to see one column, we can use the &quot;$&quot; and the column name after the variable<br>svydat$sex[1:10] # If we only want to see the first 10 rows of the sex column<br>svydat$plot_id[is.na(svydat$weight)] # If you want to know the plot_ids for where weight is missing (is.na finds missing values)<br>table(svydat$plot_id[is.na(svydat$weight)]) # Makes a summary table for each plot_id of how many entries have missing values<br>table(svydat$plot_id[!is.na(svydat$weight)]) # If we want to know the summary of how many entries we have for each of our plots where we have weight data<br><br># Let&#x27;s force record_id and plot_id to be factors (they&#x27;re now numerical) -----------------<br>svydat$plot_id &lt;- as.factor(svydat$plot_id)<br>svydat$record_id &lt;- as.factor(svydat$record_id)<br><br># Let&#x27;s look at a summary for all of our variables and make sure things make sense:<br>summary(svydat)<br><br># There are some odd values for sex and species_id. Let&#x27;s go in and make sure everything makes sense. --------------------------<br>table(svydat$plot_id, useNA=&quot;ifany&quot;) # the table() function won&#x27;t normally include missing values, but you can force it to using the useNA argument<br>levels(svydat$plot_id) # There are 24 different levels of this factor<br>levels(svydat$species_id) # We see a bunch of two letter codes for each species, but we also see some blanks. Those should be &quot;NA&quot; values<br>svydat$species_id[svydat$species_id==&quot;&quot;] &lt;- NA<br>table(svydat$species_id, useNA=&quot;ifany&quot;) # R recognizes &quot;&quot; as a level, but there aren&#x27;t actual values of that anymore in our data.&nbsp;<br>svydat$species_id &lt;- droplevels(svydat$species_id) # This will drop any unused levels from a factor variable (for us, the &quot;&quot;)<br>table(svydat$species_id, useNA=&quot;ifany&quot;)<br>svydat$sex[svydat$sex==&quot;&quot;] &lt;- NA<br>svydat$sex &lt;- droplevels(svydat$sex)<br><br># If you know your data is going to have missing values that are stored as blank, you can do this when importing your data:<br>svydat2 &lt;- read.csv(&quot;surveys.csv&quot;, header=TRUE, na.strings=&quot;&quot;)<br><br># Converting between factor and numeric can be tricky.&nbsp;<br># If you want to go numeric -&gt; factor, you can just type as.factor() around your variable and that&#x27;s fine.&nbsp;<br>svydat2$hindfoot_length &lt;- as.factor(svydat2$hindfoot_length)<br>svydat$hindfoot_length[1:10]<br>svydat2$hindfoot_length[1:10]<br><br># But now let&#x27;s say you want to go from factor -&gt; numeric. You might think you could use the as.numeric() function:<br>as.numeric(svydat2$hindfoot_length)[1:10]<br># Whaaaat?<br># When you change values into a factor, it stores them alpha-numerically in order. So, things starting with &quot;a&quot; will be listed first. When you go to change back to numeric, it will reassign the value of where the level was in the list of all factor levels. That&#x27;s NOT what you want!<br># Two things you can do to change factors into numerics:<br>as.numeric(as.character(svydat$hindfoot_length))[1:10] # Change to a character and then back to a number<br>as.numeric(levels(svydat2$hindfoot_length))[svydat2$hindfoot_length][1:10] # This is more confusing, but this is faster if you have large data<br><br><br><br><br># dplyr ----------------------------------<br><br># If you have your own computer and haven&#x27;t installed this package yet, type:<br>install.packages(&quot;dplyr&quot;)<br><br># Everyone should then load the package:<br>library(&quot;dplyr&quot;)<br><br># Create a local dataframe<br>svy &lt;- tbl_df(svydat)&nbsp;<br><br># What does this do?<br># It&#x27;ll print out info on your table in a pretty way on your screen. It&#x27;ll only show what will fit on your screen and it&#x27;ll list what you can&#x27;t see.&nbsp;<br># Otherwise it&#x27;s fine to do anything we&#x27;re going to do the rest of the afternoon on a normal data.frame<br># Carefull: local dataframes do not retain row.names!<br>print(svy, n=20) # will show you more than the 10 things the local dataframe will display by default<br><br># 5 main verbs&#x2F;functions in dplyr:<br>&nbsp;&nbsp;&nbsp; # filter<br>&nbsp;&nbsp;&nbsp; # select<br>&nbsp;&nbsp;&nbsp; # arrange<br>&nbsp;&nbsp;&nbsp; # mutate<br>&nbsp;&nbsp;&nbsp; # summarize (+ groupby)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br># FILTER: ------------------------<br># Will return only the ROWS that meet the criteria you want to see.&nbsp;<br># If we only wanted to see entries from January, 1983<br>svy[svy$year==1983 &amp; svy$month==1, ] # Base R<br>filter(svy, year==1983, month==1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # dplyr<br>jan1983 &lt;- filter(svy, year==1983, month==1) # Save that filtered data to a new variable<br><br># What if we only wanted to see entries from January, 1983 for the species &quot;DS&quot;<br>print(svy[svy$year==1983 &amp; svydat$month==1 &amp; svy$species_id==&quot;DS&quot;, ], n=22)<br>print(svy[svy$year==1983 &amp; svydat$month==1 &amp; svy$species_id==&quot;DS&quot; &amp; !is.na(svy$species_id), ], n=22)<br>filter(svy, year==1983, month==1, species_id==&quot;DS&quot;) # If you do this filtering with dplyr, it&#x27;ll automatically filter out the NA values we saw with the base R command<br><br># What if we wanted to keep all the observations for the species labeled &quot;UP&quot; and &quot;UR&quot;<br>filter(svy, species_id==&quot;UP&quot; | species_id==&quot;UR&quot;)<br>filter(svy, species_id %in% c(&quot;UR&quot;, &quot;UP&quot;)) # If we have a long list we can use the %in%&nbsp;<br><br># Challenge: Create a data.frame containing observations for species &quot;PF&quot; where the weight is not missing.&nbsp;<br># How many males and females are there in that data set?&nbsp;<br><br>pf &lt;- filter(svy, species_id==&quot;PF&quot;, !is.na(weight))<br>table(pf$sex)<br><br><br># SELECT: ----------------------<br># Will pull out COLUMNS we&#x27;re interested in<br><br># Let&#x27;s say we only want species, sex, hindfoot_length, and weight<br>svy[ ,c(&quot;species_id&quot;, &quot;sex&quot;, &quot;hindfoot_length&quot;, &quot;weight&quot;)] # base R<br>select(svy, species_id, sex, hindfoot_length, weight) # dplyr<br><br># Can also chose columns in a row:<br>select(svy, sex:weight, contains(&quot;id&quot;)) # The contains will pull anything containing &quot;id&quot;, so &quot;record_id&quot; and &quot;plot_id&quot;, the sex:weight shows all columns between sex and weight (including)<br># In addition to contains(), you can use starts_with(), ends_with(), matches()&nbsp;<br><br><br># &quot;chaining&quot; or &quot;pipes&quot; --------------------------<br># Comes from a package in R from magrittr package (comes with dplyr, so you have it already)<br># Allows you to take output from one function and dump it in the next function, rather than nesting several functions or having to save intermediate data over and over<br><br># We want to return year, species, and weight, but only when weight is less than 5.<br># Just using what we know so far, we can do this in two steps:<br>sp_wts = select(svy, year, species_id, weight)<br>filter(sp_wts, weight &lt; 5)<br><br># This creates an intermediate dataset, which we don&#x27;t need.&nbsp;<br># We could nest our functions:<br>filter(select(svy, year, species_id, weight), weight&lt;5) # This first evaluates the inside command (the select), then the outside command (the filter).&nbsp;<br># This is ok, but it can get very confusing when you nest many things.&nbsp;<br><br># How can we do this with pipes?&nbsp;<br>svy %&gt;%<br><ul class="indent"><li>select(year, species_id, weight) %&gt;%</li><li>filter(weight &lt; 5)</li></ul><br># %&gt;% is a &quot;pipe&quot;. Anytime you see this, the output of the expression to the left of the pipe is input into the expression that is to the right of the pipe.&nbsp;<br># The pipes are much easier to read than a bunch of nested functions<br><br># We can save the output to a variable to use later:<br>sm_sp &lt;- svy %&gt;%<br><ul class="indent"><li>select(year, species_id, weight) %&gt;%</li><li>filter(weight &lt; 5)</li><li><br></li></ul># Challenge: Create a data.frame with year, species_id, and weight for observations from the year 2000.&nbsp;<br># What is the mean weight of those observations?<br>sp2000 &lt;- svy %&gt;%<br><ul class="indent"><li>select(year, species_id, weight) %&gt;%</li><li>filter(year==2000)</li></ul>summary(sp2000$weight) # Summary will ignore NA values<br>mean(sp2000$weight) # the mean() will not ignore the NA and instead return an NA<br>mean(sp2000$weight, na.rm=TRUE) # But you can do this<br><br># Or, you could filter out any NAs in your command to generate sp2000<br>sp2000 &lt;- svy %&gt;%<br><ul class="indent"><li>select(year, species_id, weight) %&gt;%</li><li>filter(year==2000 $ !is.na(weight))</li></ul>mean(sp2000$weight<br><br><br># ARRANGE -------------------------<br># Let&#x27;s say we want to return year, month, sex, and hindfoot_length, but sorted by year and month<br>svy[order(svy$year, svy$month), c(&quot;year&quot;, &quot;month&quot;, &quot;hindfoot_length&quot;)] # Base R<br>svy %&gt;%<br><ul class="indent"><li>select(year, month, hindfoot_length) %&gt;%</li><li>arrange(year, month)</li><li><br></li></ul># The year is getting bigger in our table. What if we wanted to sort from soonest to most past by year? Use the desc() function to sort descending<br>svy %&gt;%<br><ul class="indent"><li>select(year, month, hindfoot_length) %&gt;%</li><li>arrange(desc(year), month)</li></ul><br><br># MUTATE -------------------------------<br># What if we want to create a new variable: the ratio of weight to hindfoot length<br>svy$w1ratio1 &lt;- svy$weight&#x2F;svy$hindfoot_length # base R<br>mutate(svy, wlratio2=weight&#x2F;hindfoot_length) # dplyr, doesn&#x27;t actually save it to the dataset<br>svy %&gt;%<br><ul class="indent"><li>mutate(wlratio2 = weight&#x2F;hindfoot_length) # With pipes, doesn&#x27;t actually save it to the dataset</li></ul># If we want to save that to the dataset:<br>svy &lt;- svy %&gt;%<br><ul class="indent"><li>mutate(wlratio2 = weight&#x2F;hindfoot_length)&nbsp;</li></ul><br># What if we want to get rid of variables from our dataset?<br>svy &lt;- svy %&gt;%<br><ul class="indent"><li>transmute(wlratio=NULL, wlratio2=NULL)</li><li><br></li></ul><br># SUMMARISE -------------------------------<br># useful with the group_by function to create quick summaries of the variables in your dataset<br># What if we want to calculate average weight by species?&nbsp;<br>tapply(svy$weight, svy$species_id, mean, na.rm=TRUE) # One way in base R<br>aggregate(weight ~ species_id, svy, mean) # Another base R way. Will only return species where it can compute the mean (it&#x27;ll remove the species with NaNs)<br>svy %&gt;%<br><ul class="indent"><li>group_by(species_id) %&gt;%</li><li>summarise(mean(weight, na.rm=TRUE))</li></ul># That kept in species with NAs, but we could filter them out by piping on filtering commands:<br>svy %&gt;%<br><ul class="indent"><li>group_by(species_id) %&gt;%</li><li>filter(!is.na(weight)) %&gt;%</li><li>summarise(mean(weight))</li><li><br></li></ul># Can also use summarise to count the number of observations in your dataset:<br>svy %&gt;%<br><ul class="indent"><li>group_by(month) %&gt;%</li><li>summarise(count=n())</li></ul><br># Or by using the tally command:<br>svy %&gt;%<br><ul class="indent"><li>group_by(month) %&gt;%</li><li>tally</li></ul><br># Challenge: For each species and year, count the number of observations per sex and also calculate the mean weight&nbsp;&nbsp;&nbsp;&nbsp;<br>svy %&gt;%<br><ul class="indent"><li>group_by(species_id, year, sex) %&gt;%</li><li>filter(!is.na(weights)) %&gt;%</li><li>summarise(count=n(), mean_wt=mean(weight))</li><li><br></li><li><br></li></ul># Create dataset for plots after break: -----------------------------<br># Remove observations with missing values for species_id, weight, hindfoot_length, sex<br>svy_complete &lt;- svy %&gt;%<br><ul class="indent"><li>filter(!is.na(species_id), !is.na(weight), !is.na(hindfoot_length), !is.na(sex))</li></ul><br># Let&#x27;s also remove any species where there aren&#x27;t many observations (perhaps they aren&#x27;t reliable or we just want to make sure we have many observations)<br>species_nonrare &lt;- svy %&gt;%<br><ul class="indent"><li>group_by(species_id) %&gt;%</li><li>summarise(count=n()) %&gt;%</li><li>filter(count &gt;= 50, !is.na(species_id)) %&gt;%</li><li>select(species_id)</li><li><br></li></ul># Only keep data from svy_complete for species in the nonrare dataset:<br>svy_complete &lt;- svy_complete %&gt;%<br><ul class="indent"><li>filter(species_id %in% species_nonrare$species_id)</li><li><br></li></ul># Your dimensions should be 30463 rows with 9 columns<br><br># To write the file into your project folder:<br>write.csv(svy_complete, &quot;svy_complete.csv&quot;, row.names=FALSE)<br><br><br><br><br><br><br># ggplot2 ----------------------------------<br># If you are on your own computer and don&#x27;t have ggplot2 installed, run:<br>install.packages(&quot;ggplot2&quot;)<br><br># Everyone, load ggplot2:<br>library(&quot;ggplot2&quot;)<br><br># Let&#x27;s all load the dataset from the webpage to make sure we all are working with the same data:<br><a href="http&#x3a;&#x2F;&#x2F;erdavenport&#x2e;github&#x2e;io&#x2F;2016&#x2d;06&#x2d;13&#x2d;cornell&#x2F;">http:&#x2F;&#x2F;erdavenport.github.io&#x2F;2016-06-13-cornell&#x2F;</a><br><br># Clear out everything we did earlier, start with a fresh R session:<br>rm(list=ls(all=TRUE))<br><br># Read in the data we just downloaded:<br>svy &lt;- read.csv(&quot;svy_complete.csv&quot;, header=TRUE)<br><br># What does ggplot do?<br># ggplot initializes a basic graph structure, then elements are added to the plot<br># aes (aesthetics) - maps the variables to the plot<br># geom - add geometric objects to the plot (geom_point, geom_line, geom_boxplot, geom_smoother, etc.)<br># scales - modify axes and labels<br># facets - plot different panels of your data<br><br># Three examples: scatterplot, side-by-side boxplots, and longitudinal data<br><br># Scatterplots --------------------------------------<br># Let&#x27;s make a scatterplot of hindfoot length vs. weight<br>ggplot(data=svy) # Initializes plot, don&#x27;t really see anything!<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length)) # Initializes plot, shows the axes, but no data yet<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length)) + # This will add the points.<br><ul class="indent"><li>geom_point()</li></ul># Note, if you spit a command over two lines, keep the pluses on the prior line<br># You can save plots as objects:<br>svy_plot &lt;- ggplot(data=svy, aes(x=weight, y=hindfoot_length) # That&#x27;s saved and we can run it later.&nbsp;<br>svy_plot + geom_point()<br><br># How can we customize our plots?<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length)) +<br><ul class="indent"><li>geom_point(alpha=0.05) # alpha controls the transparency of the points. So, we should get more transparent points</li></ul><br># Change color:<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length)) +<br><ul class="indent"><li>geom_point(alpha=0.05, color=&quot;blue&quot;) # color will set the color of the points</li><li><br></li></ul># Color by species:<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length)) +<br><ul class="indent"><li>geom_point(alpha=0.05, aes(color=species_id)) # color by species_id</li><li><br></li></ul># We could have included the color information in the first ggplot call. Then, those colors would be the default for any plot that you add on:<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length, color=species_id)) +<br><ul class="indent"><li>geom_point(alpha=0.05) # color by species_id</li></ul><br># Let&#x27;s add on some nicer labels:<br>ggplot(data=svy, aes(x=weight, y=hindfoot_length, color=species_id)) +<br><ul class="indent"><li>geom_point(alpha=0.05) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Make points transparent</li><li>xlab(&quot;Weight (g)&quot;) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set the x-axis labels to be Weight (g)</li><li>ylab(&quot;Hindfoot Length (mm)&quot;) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set the y-axis label to be Hindfoot Length (mm)</li><li>scale_color_discrete(name=&quot;species&quot;)&nbsp; # Change the label above the legend</li></ul><br># side-by-side boxplots for hindfoot_length by species<br>ggplot(data=svy, aes(x=species_id, y=hindfoot_length)) +<br><ul class="indent"><li>geom_boxplot()</li></ul><br>ggplot(data=svy, aes(x=species_id, y=hindfoot_length)) +<br><ul class="indent"><li>geom_boxplot() +</li><li>geom_jitter(alpha=0.1, color=&quot;tomato&quot;)</li></ul><br>ggplot(data=svy, aes(x=species_id, y=hindfoot_length)) +<br><ul class="indent"><li>geom_boxplot() +</li><li>geom_jitter(alpha=0.1, color=&quot;tomato&quot;) +</li><li>geom_boxplot() +</li><li>xlab(&quot;Species Code&quot;) +</li><li>ylab(&quot;Hindfoot Length (mm)&quot;)</li></ul><br># Challenge: Create violin plots of weight by species (using geom_violin) without the jitter; add appropriate axis labels and a main title (using ggtitle)<br>ggplot(data=svy, aes(x=species_id, y=weight)) +<br><ul class="indent"><li>geom_violin() +</li><li>xlab(&quot;Species code&quot;) +</li><li>ylab(&quot;Weight (g)&quot;) +</li><li>ggtitle(&quot;Weight by Species&quot;)</li></ul><br># Eeek, ugly. Looks like the distribution of our weights are skewed. Let&#x27;s put the y-axis on a log scale:<br>ggplot(data=svy, aes(x=species_id, y=weight)) +<br><ul class="indent"><li>geom_violin() +</li><li>xlab(&quot;Species code&quot;) +</li><li>ylab(&quot;Weight (g)&quot;) +</li><li>ggtitle(&quot;Weight by Species&quot;) +</li><li>scale_y_log10()</li></ul><br># Longitudinal plot of the number of each species over time (year). Create a dataframe of counts by year and species<br>yearly_counts &lt;- svy %&gt;%<br><ul class="indent"><li>group_by(year, species_id) %&gt;%</li><li>tally</li></ul><br>ggplot(data=yearly_counts, aes(x=year, y=n)) +<br><ul class="indent"><li>geom_line()</li></ul><br># We aren&#x27;t distinguishing by species above, not useful. We want separate lines for each species.&nbsp;<br>ggplot(data=yearly_counts, aes(x=year, y=n, group=species_id)) +<br><ul class="indent"><li>geom_line()</li><li><br></li></ul># Better! There are multiple lines now, but we can&#x27;t tell which is which. Let&#x27;s color by species:<br>ggplot(data=yearly_counts, aes(x=year, y=n, group=species_id, color=species_id)) +<br><ul class="indent"><li>geom_line()</li><li><br></li></ul># Sometimes we&#x27;ll want a separate plot for each of our species, rather than having a bunch of lines on one plot. We can do this using faceting:<br>ggplot(data=yearly_counts, aes(x=year, y=n, group=species_id, color=species_id)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_wrap(~ species_id)</li></ul><br># Now, what if we want to split by sex? First, create a new dataset:<br>yearly_sex &lt;- svy %&gt;%<br><ul class="indent"><li>group_by(year, species_id, sex) %&gt;%</li><li>tally</li></ul><br># And plot:<br>ggplot(data=yearly_sex, aes(x=year, y=n, color=species_id, group=sex)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_wrap(~species_id)</li></ul><br># Can&#x27;t tell which sex is which. Let&#x27;s color by sex rather than species.<br>ggplot(data=yearly_sex, aes(x=year, y=n, color=sex, group=sex)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_wrap(~species_id)</li><li><br></li></ul># You can change the appearance of your graphs by changing the theme:<br>ggplot(data=yearly_sex, aes(x=year, y=n, color=sex, group=sex)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_wrap(~species_id) +</li><li>theme_bw() # This will get rid of the gray background</li><li><br></li></ul># Challenge: plot the average weight for each species over time by year. Hint: need to use dplyr first to create the dataset to plot.&nbsp;<br># First, create the dataset:<br>yearly_wt &lt;- svy %&gt;%<br><ul class="indent"><li>group_by(year, species_id) %&gt;%</li><li>summarize(avg_wt = mean(weight))</li></ul>ggplot(data=yearly_wt, aes(x=year, y=avg_wt, color=species_id)) +<br><ul class="indent"><li>geom_line()</li><li><br></li></ul># Now let&#x27;s break this up by sex as well:<br>yearly_wt_sex &lt;- svy %&gt;%<br><ul class="indent"><li>group_by(year, species_id, sex) %&gt;%</li><li>summarize(avg_wt=mean(weight))</li></ul>ggplot(data=yearly_wt_sex, aes(x=year, y=avg_wt, color=species_id, group=species_id)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_wrap(~ sex)</li></ul><br># What if we want the two sexes to be two rows rather than columns? Use facet_grid instead:<br>ggplot(data=yearly_wt_sex, aes(x=year, y=avg_wt, color=species_id, group=species_id)) +<br><ul class="indent"><li>geom_line() +</li><li>facet_grid(sex ~ .)</li></ul><br><br><br><br><strong>Tuesday Morning</strong><br><br>This morning we&#x27;ll start with databasing with SQL.<br><br>If you don&#x27;t still have the data from yesterday, get it here: <a href="https&#x3a;&#x2F;&#x2F;figshare&#x2e;com&#x2F;articles&#x2F;Portal&#x5f;Project&#x5f;Teaching&#x5f;Database&#x2F;1314459">https:&#x2F;&#x2F;figshare.com&#x2F;articles&#x2F;Portal_Project_Teaching_Database&#x2F;1314459</a><br><br>To open the database, click the arrow into the folder button in SQL and open the mammals_portal.sql<br><br>Great, but how can we make a database using our own data?&nbsp;<br>First, make sure individual tables of yours are tidy (rectangular, single observation per row, etc.)<br><br>You can create your own database by importing the three excel files from the ecology project<br><br>To query the database, click on the surveys table, and then the &quot;Execute SQL&quot; tab:<br>Let&#x27;s pull the year column from the surveys table:<br>SELECT year FROM surveys<br><br>We can select multiple columns by separating with commas. Let&#x27;s pull year, month, and day from surveys:<br>SELECT year, month, day FROM surveys<br><br>The &quot;*&quot; is a wildcard character and means to pull everything:<br>SELECT * FROM surveys<br><br>It is good form to use all caps for SQL commands and use lowercase for your variables<br><br>The DISTINCT command will pull the unique values within a column.&nbsp;<br>SELECT DISTINCT species_id FROM surveys<br><br>It can also be used to pull unique combinations if you put in multiple columns<br>SELECT DISTINCT species_id, year FROM surveys<br><br>You can also do calculations from within the query. Let&#x27;s display weight in kg rather than g:<br>SELECT plot_id, species_id, sex, weight&#x2F;1000 FROM surveys<br><br>Floats vs. intergers. If you want to force a result of a computation to be a float when performing an operation, make sure there&#x27;s a decimal:&nbsp;<br>SELECT plot_id, species_id, sex, weight&#x2F;1000.0 FROM surveys<br><br>You can display only certain numbers of decimals by using the ROUND function:<br>SELECT plot_id, species_id, sex, ROUND(weight&#x2F;1000.0, 2) FROM surveys<br><br>Challenge:<br>Write a query that returns the year, month, day, species_id, and weight in mg.<br><br>Answer:<br>SELECT year, month, day, species_id, weight*1000 FROM surveys<br><br>Filtering ------------------------<br>You can also use SQL to select only certain rows using the FILTER command<br>SELECT year, month, species_id, weight*1000 FROM surveys WHERE species_id=&quot;DM&quot;<br><br>Our query is getting long. Convention is that you put each new command on a new line to keep things readable. End the command to the semi-colon:<br>SELECT year, month, species_id, weight*1000&nbsp;<br>FROM surveys&nbsp;<br>WHERE species_id=&quot;DM&quot;;<br><br>Can also include numeric conditionals. What if we only want records from after the year 2000?<br>SELECT year, month, species_id, weight*1000&nbsp;<br>FROM surveys&nbsp;<br>WHERE year &gt;= 2000;<br><br>Can also have more complicated conditions using AND OR statements. For example, if we want only DM species after the year 2000:<br>SELECT year, month, species_id, weight*1000&nbsp;<br>FROM surveys&nbsp;<br>WHERE year &gt;= 2000 AND species_id=&quot;DM&quot;;<br><br>Style statement - you can wrap things in parenthases to make things more readable:<br>SELECT year, month, species_id, weight*1000&nbsp;<br>FROM surveys&nbsp;<br>WHERE (year &gt;= 2000) AND (species_id=&quot;DM&quot;);<br><br>What if we wanted all of the diplo species?<br>SELECT year, month, species_id, weight*1000&nbsp;<br>FROM surveys&nbsp;<br>WHERE (species_id=&quot;DM&quot;) OR (species_id=&quot;DO&quot;) OR (species_id=&quot;DS&quot;);<br><br>Challenge:&nbsp;<br>Write a query that returns the day, month, year, species_id, and weight (in kg) for individuals caught on Plot 1 that weight more than 75g<br><br>Answer:<br>SELECT day, year, month, species_id, weight&#x2F;1000.0&nbsp;<br>FROM surveys&nbsp;<br>WHERE (plot_id==1) AND (weight &gt; 75);<br><br>What if we have a bunch of species we want to select? We can use an IN statement, similar to dplyr in R yesterday:<br>SELECT day, year, month, species_id, weight&#x2F;1000.0&nbsp;<br>FROM surveys&nbsp;<br>WHERE (species_id IN (&quot;DO&quot;, &quot;DM&quot;, &quot;DS&quot;));<br><br>It&#x27;s always good to start simple with your queries and build up. Also, comment SQL code using at least two dashes at the beginning of a line:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>-- Get post 2000 data on Dipodomys sepcies<br>-- This info is in the surveys table, want all columns<br>SELECT *<br>FROM surveys<br>-- Sampling year is in the column &quot;year&quot; and we want include 2000 and later<br>WHERE (year &gt;= 2000);<br><br>You can also sort in SQL using the command ORDER BY. Let&#x27;s say we want to sort by the taxa name in ascending order (ASC):<br>SELECT *<br>FROM species<br>ORDER BY taxa ASC;<br><br>Descending order is (DESC).<br>Can combine multiple sorts together as well:<br>SELECT *<br>FROM species<br>ORDER BY taxa ASC, species ASC;<br><br>Challenge:<br>Write a query that returns year, species, and weight in kg from the surveys table, sorted with the largest weights at the top.&nbsp;<br><br>Answer:<br>SELECT year, species_id, weight&#x2F;1000.<br>FROM surveys<br>ORDER BY weight DESC;<br><br>You can sort by columns you don&#x27;t even include as output:<br>SELECT genus, species<br>FROM species<br>WHERE taxa=&quot;Bird&quot;<br>ORDER BY species_id ASC;<br><br>Order of operations in SQL: Filters with WHERE, then ORDERS the results, then will show the results with SELECT<br><br>Challenge:<br>Let&#x27;s combine everything together: Using the surveys table write a query to display the three date fields, species_id, and weight in kg (rounded to two decimal places), for individuals captures in 1999, ordered alphabetically by the species_id. Write the query as a single line, then put each clause on it&#x27;s own line and see how much more legible the query becomes.&nbsp;<br><br>Answer:<br>SELECT year, month, day, species_id, ROUND(weight&#x2F;1000.0, 2)<br>FROM surveys<br>WHERE year=1999<br>ORDER BY species_id ASC;<br><br>You can also use aggregation functions within SQL to get summaries of your data. How many entries do we have in all columns? How much does everything in our dataset weigh? Can we round that to 2 decimal places?<br>SELECT COUNT(*), ROUND(SUM(weight)&#x2F;1000.0, 2)<br>FROM surveys;<br><br>Challenge:<br>Write a query that returns: total weight, average weight, and the min and max weights for all animals caught over the duration of the survey. Can you modify it so that it outputs these values only for weights between 5 and 10?<br><br>Answer:<br>SELECT SUM(weight), AVG(weight), MIN(weight), MAX(weight)<br>FROM surveys<br>WHERE (weight &gt;=5) AND (weight&lt;=10);<br><br>Often times you don&#x27;t want to average over everything in a data frame, but by a variable. Just like dplyr, you can use GROUP BY to aggregate by some variable in your set. For instance, by species_id:<br>SELECT SUM(weight), AVG(weight), MIN(weight), MAX(weight)<br>FROM surveys<br>WHERE (weight &gt;=5) AND (weight&lt;=10)<br>GROUP BY species_id;<br><br>Challenge:<br>Write queries that return: How many individuals were counted in each year per each species.<br>Also, average the weight of each species in each year. Can you modify the above queries combining them into one.<br>SELECT species_id, COUNT(*), AVG(weight)<br>FROM surveys<br>GROUP BY year;<br><br>If you want to use an aggregate statistic, you can use the HAVING function:<br>SELECT species_id, COUNT(species_id)<br>FROM surveys<br>GROUP BY species_id<br>HAVING COUNT(species_id) &gt;10<br>ORDER BY COUNT(species_id);<br><br>You can save SQL queries for future use. Why would you want to do this? You can run the same queries on updated data. To do this, you need to CREATE VIEW:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>CREATE VIEW species_count AS<br>SELECT species_id, COUNT(species_id)<br>FROM surveys<br>GROUP BY species_id<br>HAVING COUNT(species_id) &gt;10<br>ORDER BY COUNT(species_id);<br><br>Now if you look over to the side, you&#x27;ll see a new table under the views tab. If you update your data, this table will update too.&nbsp;<br><br>You can query a view just like a table:<br>SELECT *<br>FROM species_count<br><br>Challenge: Write a query that returns the number of each species caught in each year sorted from the most often caught species to the least occurring ones within each year starting from the most recent records. Save this query as a VIEW.&nbsp;<br>CREATE VIEW count_per_year AS<br>SELECT species_id, year, COUNT(*)<br>FROM surveys<br>GROUP BY year, species_id<br>ORDER BY&nbsp;<br><br>So, we have a bunch of information in multiple tables. How can we smoosh all of it together, to get the info we need into one table we can do analyses off of? We can use JOIN<br>SELECT *<br>FROM surveys<br>JOIN species<br>ON surveys.species_id = species.species_id;<br><br>Note that after the ON statement, we specify what table we want to pull from first (surveys), put a period, and then reference the column of that table we want to merge (species_id). We signify that this column matches the column from the other table (species.species_id) with the equals sign<br><br>If the column names are the same we can save some typing:<br>SELECT *<br>FROM surveys<br>JOIN species<br>USING (species_id);<br><br>If we only want certain columns from each table, you can specify which columns you want in the SELECT statement:<br>SELECT surveys.year, surveys.month, surveys.day, species.genus, species.species<br>FROM surveys<br>JOIN species<br>USING (species_id);<br><br>And you can join two tables and aggregate data as well. If you want the average weight by plot type:<br>SELECT plots.plot_type, AVG(surveys.weight)<br>FROM surveys<br>JOIN plots<br>ON surveys.plot_id=plots.plot_id<br>GROUP BY plots.plot_type;<br><br>SQL also has functions for missing data. If you want to recategorize missing data, you can use the IFNULL command:<br>SELECT species_id, sex, IFNULL(sex, &quot;U&quot;)<br>FROM surveys;<br><br>That column name is UGLY. Also, it looks like SQL syntax, which means it would be very hard to reference it in code. We can rename it using AS:&nbsp;<br>SELECT species_id, sex, IFNULL(sex, &quot;U&quot;) AS non_null_sex<br>FROM surveys;<br><br>When we joined the surveys and species tables before, some of the records were excluded because of null values for species_id. We can fix that now by specifying a new species name if the species table data is missing. Let&#x27;s name that &quot;AB&quot;:<br>SELECT surveys.year, surveys.month, surveys.day, species.genus, species.species<br>FROM surveys<br>JOIN species<br>ON surveys.species_id = IFNULL(species.species_id, &quot;AB&quot;);<br><br>We can do the opposite as well. We can set cells to be null if they meet some criteria. For instance, let&#x27;s set a a plot_id to null if the plot_id is 7:<br>SELECT species_id, plot_id, NULLIF(plot_id, 7) AS partial_plot_id<br>FROM surveys<br><br>There are other commands that might be useful to you:<br>ABS()&nbsp;<br>LENGTH<br>LOWER<br>UPPER<br>NULLIF(x,y)<br>ROUND<br>TRIM<br><br>IFNULL<br>RANDOM<br><br>REPLACE(string, find, replace)<br><br>Challenge: Write a query that returns the number of genus of the animals caught in each plot in descending order.&nbsp;<br>Two step answer:<br>CREATE VIEW combined AS<br>SELECT *<br>FROM surveys<br>JOIN species<br>ON surveys.species_id = species.species_id;<br><br>SELECT genus, plot_id, COUNT(*)<br>FROM combined<br>GROUP BY plot_id<br>ORDER BY COUNT(*)<br><br>One step answer:<br>SELECT plot_id, genus, COUNT(*)<br>FROM surveys<br>JOIN species<br>ON surveys.species_id = species.species_id<br>GROUP BY species.genus<br>ORDER BY plot_id<br><br>Challenge: Write a query that finds the average weight of each rodent species (i.e., only include species with Rodent in the taxa field).&nbsp;<br>Answer:<br>SELECT species.species_id, AVG(weight)<br>FROM surveys<br>JOIN species<br>USING (species_id)<br>WHERE species.taxa=&quot;Rodent&quot;<br>GROUP BY surveys.species_id;<br><br><br><strong>Tuesday Afternoon</strong><br># Set up that folder with all the data on the computer you&#x27;re using if you don&#x27;t still have it.<br># Accessing your SQL database from R:<br>library(RSQLite)<br><br># To connect to your database<br>myDB &lt;- &quot;portal_mammals.sqlite&quot;<br>conn &lt;- dbConnect(drv=SQLite(), dbname=myDB)<br><br># To query the database<br>dbGetQuery(conn, &quot;SELECT count(*) FROM surveys&quot;)<br><br># To list all the tables in your database:<br>dbListTables(conn)<br><br># To list all the fields in a table:<br>dbListFields(conn, &quot;surveys&quot;)<br><br># Often you&#x27;ll want to save your query to a variable rather than type it in the dbGetQuery command. This makes it easier to read and edit your query<br>q &lt;- &quot;SELECT DISTINCT year, species_id FROM surveys&quot;<br>result &lt;- dbGetQuery(conn, q)<br><br># We can use the results of some code we run in R to query our database directly.<br># Let&#x27;s say we want information from our database for every other year in a range. First, let&#x27;s get the range of years from the data<br>yearRange &lt;- dbGetQuery(conn, &quot;SELECT min(year), max(year) FROM surveys&quot;)<br><br># Now, let&#x27;s create a sequence of every other year:<br>years &lt;- seq(yearRange[,1], yearRange[,2], by=2)<br><br><br># The paste command is super useful in R. It will &quot;paste&quot; together two either character strings or R expressions into one:<br>paste(&quot;This&quot;, &quot;That&quot;)<br><br># Now let&#x27;s write a query to pull info for those years from the database<br><br>q &lt;- paste(&quot;SELECT surveys.year species.taxa, COUNT(*) as count<br>FROM surveys<br>JOIN species<br>ON surveys.species_id=species.species_id<br>WHERE species.taxa=&#x27;Rodent&#x27; AND surveys.year IN (&quot;, paste(years, collapse=&#x27;,&#x27;),&nbsp;<br>&quot;) GROUP BY surveys.year, species.taxa&quot;, sep=&quot;&quot;)<br><br>rCount &lt;- dbGetQuery(conn, q)<br><br># We can also build a SQL database from within R.<br># Read in those csv datatables into R<br>species &lt;- read.csv(&quot;species.csv&quot;)<br>surveys &lt;- read.csv(&quot;surveys.csv&quot;)<br>plots &lt;- read.csv(&quot;plots.csv&quot;)<br><br>newDB &lt;- &quot;portalR.db&quot;<br>myConn &lt;- dbConnect(drv=SQLite(), dbname=newDB)<br>dbListTables(myConn)<br><br>dbWriteTable(myConn, &quot;species&quot;, species)<br>dbWriteTable(myConn, &quot;surveys&quot;, surveys)<br>dbWriteTable(myConn, &quot;plots&quot;, plots)<br>dbListTables(myConn)<br><br># Every time you open a database connection from R, be sure you close your connection:<br>dbDisconnect(myConn)<br><br><br><strong>Tuesday Afternoon Notes</strong><br><br>How do we communicate our results?<br>1. RMarkdown for reports<br>2. Will learn some new tricks in R, loops, and functions<br><br>Install the Rmarkdown package:<br>install.packages(&quot;rmarkdown&quot;)<br>library(rmarkdown)<br><br>We will use the same data that we used for ggplot yesterday, svy_complete.csv<br><br>Make sure that you have your project setup to the folder where the dataset is saved.<br><br>Lesson are on the course website already. These were all created with Rmarkdown, check out how pretty they are! You too can make pretty things!<br><br>In Rmarkdown, code and contents of document are interweaved, so making changes and updates is easy.<br><br>Goals:<br>1. Learn a bit about markdown code.<br>2. Learn to introduce code chunks.<br>3. Put them all together and get clever.<br><br><br>Analysis and methods all in one place!<br><br>File -&gt; New File -&gt; Text to make a readme file<br>Date<br>Name<br>Description<br><br>FIle -&gt; Save As -README.md file<br>.md=markdown<br><br>See the &quot;Preview HTML&quot; button, click it! See a txt file of what we have so far.<br><br>Let&#x27;s organize our file.<br>Create a level one comment (largest level) by putting a #<br>A level two comment can be made by two hashtags (##)<br><br>When you click Preview HTML, files will be saved before it renders.<br><br>Markdown syntax:<br><br>Add:<br>&nbsp;&nbsp;&nbsp; data files<br>&nbsp;&nbsp;&nbsp; scripts<br>&nbsp;&nbsp;&nbsp; results<br>with two spaces after each to put them on separate lines<br><br>Blank lines will still be blank lines even without the two spaces<br><br>Add *&#x27;s to get bullets:<br>&nbsp;&nbsp; * data files<br>&nbsp;&nbsp; * scripts<br>&nbsp;&nbsp; * results<br><br>To make **bold** and to make _italicized_<br><br>Comments in R markdown can be made like this: &lt;!-- comment here --&gt;<br><br>`cat README.md` to add an emphasis<br><br><br>Adding a code block for commands to execute in R:<br>&nbsp;&nbsp;&nbsp; begin with ```<br>and end with ```<br><br><br>```<br>install.packages(&quot;rmarkdown&quot;)<br>```<br><br>now we have a code block!<br><br><br>Hyperlinks:<br>&nbsp;&nbsp;&nbsp; 2 methods:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) Wrap the text in the hyperlink in square brackets followed by the hyperlink in parentheses: i.e. [Text](hyperlink)<br><br>The data for this project originally came from the [Portal Project Teaching Database](<a href="https&#x3a;&#x2F;&#x2F;figshare&#x2e;com&#x2F;articles&#x2F;Portal&#x5f;Project&#x5f;Teaching&#x5f;Database&#x2F;1314459&#x29;">https:&#x2F;&#x2F;figshare.com&#x2F;articles&#x2F;Portal_Project_Teaching_Database&#x2F;1314459)</a><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) To link to individual data files. Surround the text in square brackets, followed by another set of square brackets, supplying a reference id. On the following line, provide the hyperlink to the references<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : i.e. [Text1][ref1] [Text2][ref2]<br><ul><ul><ul class="indent"><li>[ref1]=<a href="https&#x3a;&#x2F;&#x2F;cornell&#x2e;edu">https:&#x2F;&#x2F;cornell.edu</a></li><li>[ref2]=<a href="https&#x3a;&#x2F;&#x2F;cscu&#x2e;cornell&#x2e;edu">https:&#x2F;&#x2F;cscu.cornell.edu</a></li></ul></ul></ul><br>The data files were downloaded 6&#x2F;14&#x2F;16, including both [species level data][link1] and [plot level data][link2].<br><br>[link1]:<a href="https&#x3a;&#x2F;&#x2F;ndownloader&#x2e;figshare&#x2e;com&#x2F;files&#x2F;2292169">https:&#x2F;&#x2F;ndownloader.figshare.com&#x2F;files&#x2F;2292169</a><br>[link2]:<a href="https&#x3a;&#x2F;&#x2F;ndownloader&#x2e;figshare&#x2e;com&#x2F;files&#x2F;3299474">https:&#x2F;&#x2F;ndownloader.figshare.com&#x2F;files&#x2F;3299474</a><br><ul><ul><ul class="indent"><li>&nbsp;</li></ul></ul></ul>Can do all sorts of other formatting as well: indents, lists, etc - just google it!<br><br>File -&gt; New File -&gt; R Markdown<br><br><br>Title = On the original of my dissertation<br>Author = Me.<br><br>Using HTML as default output<br><br>Will produce a new R Markdown file with a template. Can help you to get started if you are new to Rmd or just haven&#x27;t used it in awhile.<br><br>&quot;Knit HTML&quot; is in the place where &quot;preview HTML&quot; was before.<br>Will ask you to save the file as a .Rmd file.<br>The R code is evaluated! The code and the output is included in the document.&nbsp;<br><br>Let&#x27;s add some more text to the end of the file.<br><br>The dimension of the cars dataset are:<br>```{r}<br>dim(cars)<br>```<br><br>Can also use&nbsp; Chunks -&gt; Insert Chunk&nbsp;<br>OR<br>Ctrl+Alt+I<br>so you don&#x27;t have to keep writing ```{r} ```<br><br><br>Chunk options:<br>&nbsp;&nbsp;&nbsp; Sometimes we want to see the R code in the file, sometimes we don&#x27;t!<br>&nbsp;&nbsp;&nbsp; There are options!<br><br>echo=FALSE option means that the R code will not be printed into the document.<br><br>Can give names to the chunks to make navigation easier:<br>```{r summary}<br>summary(cars)<br>```<br><br>Using the Chunk # menu at the bottom of the .Rmd file, you can jump from chunk to<br>chunk. Give the chunks useful names!<br><br>What if you have code that you want run, but not shown? You can hide your results:<br>```{r summary2, results=&quot;hide&quot;}<br>summary(cars)<br>```<br><br>```{r summary3, include=FALSE}<br>summary(cars)<br>```<br><br>Make a new Rmd file.&nbsp; And knit.<br><br>Insert chunk to load data<br><br># Loading the data<br>```{r}<br>surveys_raw &lt;-&nbsp; read.csv(&quot;<a href="https&#x3a;&#x2F;&#x2F;ndownloader&#x2e;figshare&#x2e;com&#x2F;files&#x2F;2292172">https:&#x2F;&#x2F;ndownloader.figshare.com&#x2F;files&#x2F;2292172</a>&quot;, header=TRUE)<br>or download the data onto your computer instead of using the URL.<br>```<br><br># Loading the libraries<br>```{r load libraries}<br>library(ggplot2)<br>library(dplyr)<br>```<br><br>#Filter the data<br>Removing missing records with missing values from species_id, weights, or hindfoot lengths:&nbsp;<br><br>Removing records with missing values:<br>```{r filter data}<br>surveys_complete &lt;- surverys_raw %&gt;%<br>&nbsp; filter(species_id !=&quot;&quot;) %&gt;%<br>&nbsp; filter(!is.na(weight)) %&gt;%<br>&nbsp; filter(!is.na(hindfoot_length))<br>```<br><br>Removing records for rare species:<br>```{r remove rare}<br>species_counts &lt;- surveys_complete %&gt;%<br>&nbsp; group_by(species_id) %&gt;%<br>&nbsp; tally<br><br>head(species_counts)<br><br>frequent_species &lt;- species_counts %&gt;%<br>&nbsp; filter(n&gt;=10) %&gt;%<br>&nbsp; select(species_id)<br>&nbsp;&nbsp;<br>survey_complete &lt;- surveys_complete %&gt;%<br>&nbsp; filter(species_id %in% species_counts$species_id)<br>```<br><br>Other markdown options:<br>```{r, warning=FALSE, message=FALSE, include=TRUE, echo=TRUE}&nbsp;<br>```<br><br># Analysis<br>The distribution of hindfoot lengths as a function of species:<br>```{r}<br>ggplot(data=surveys_complete, aes(x=species_id, y=hindfoot_length)) +<br>&nbsp; geom_boxplot()<br>```<br><br>Lets add a table of contents. Change header to&nbsp;<br>---<br>title: &quot;Ecology Test&quot;<br>author: :Name&quot;<br>date: &quot;June 14, 2016&quot;<br>output:&nbsp;<br>&nbsp; html_document:<br>&nbsp;&nbsp;&nbsp; toc: true<br>---<br><br>Add extra cool things like numbered sections, colors and themes, figure size options<br>MAKE SURE TO INDENT AS SHOWN AND INCLUDE SPACES AFTER THE COLONS!!!!!!!!!!!<br>---<br>title: &quot;Ecology Test&quot;<br>author: :Name&quot;<br>date: &quot;June 14, 2016&quot;<br>output:&nbsp;<br>&nbsp; html_document:<br>&nbsp;&nbsp;&nbsp; toc: true<br>&nbsp;&nbsp;&nbsp; number_sections: true<br>&nbsp;&nbsp;&nbsp; theme: cerulean<br>&nbsp;&nbsp;&nbsp; highlight: espresso<br>&nbsp;&nbsp;&nbsp; fig_width: 10<br>&nbsp;&nbsp;&nbsp; fig_height: 3<br>---<br><br>How do to figure captions<br><br>add to the header the option<br>---<br>title: &quot;Ecology Test&quot;<br>author: :Name&quot;<br>date: &quot;June 14, 2016&quot;<br>output:&nbsp;<br>&nbsp; html_document:<br>&nbsp; figure captions: yes<br>---<br><br>Then within a chunk, specify the name of the figure caption&nbsp;<br>```{r remove rare , fig.cap=&quot;Figure 1: Hindfoot length wihin each species&quot;}<br>[INSERT R CODE HERE<br>```<br><br><br>While it&#8217;s nice to have all of your code and results in one place, sometimes you&#8217;ll also want your figures printed to a separate file so that you can include them in manuscripts, presentations, or posters. You can specify the self_contained option as false in the header, which will generate all the files used to render the HTML.<br><br>---<br>title: &quot;Ecology Test&quot;<br>author: :Name&quot;<br>date: &quot;June 14, 2016&quot;<br>output:&nbsp;<br>&nbsp; html_document:<br>&nbsp; self_contained: false<br>---<br><br>When you render HTML, it will create a folder with all the image files needed to put into the html document<br><br>Challenge:&nbsp;<br>&nbsp;&nbsp;&nbsp; 1) Hide code for boxplots<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; add &quot;echo=FALSE&quot; to chunk</li></ul>&nbsp;&nbsp;&nbsp; 2) Change fig dimension to 8 x 8<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; Change fig_width and fig_height in header</li></ul>&nbsp;&nbsp;&nbsp; 3) Add another boxplot plotting the distributions of weights across the species, ensuring there are respectable titles and axis labels. Also, just like the previous figure, make sure there is a legend and that the code to generate the figure does not appear in the final report.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a new code chunk,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```{r boxplot 2, , echo=FALSE }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ggplot(data=surveys_complete, aes(x=species_id, y=weight))+geom_boxplot() + xlab(&quot;Species&quot;) +ylab(&quot;Weight (g)&quot;)<br>```<br><br>&nbsp;&nbsp;&nbsp; 4) Add a sentence under the new figure:&nbsp; &#8220;The total number of species examined is X&#8221;, where X is the total number of species in the filtered dataset, as evaluated by inline code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In the markdown section (i.e. not in a code chunk) write:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;The total number of species examined is `r count(frequent_species)`.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;Programming Basics- Make a new markdown document<br>&nbsp;<br>&nbsp;<br>&nbsp;If&#x2F;else statements<br>&nbsp;<br>&nbsp;Let&#8217;s say that we discover from our collaborator that there was an issue in 1984. All of the scales had not been calibrated, and we need to increase the weights of any measurements made in that year by 10%. How can we go through and update our table?<br>&nbsp;<br>&nbsp;use svy_complete.csv<br>&nbsp;<br>&nbsp;library(&quot;dplyr&quot;)<br>&nbsp;library(&quot;ggplot2&quot;)<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>surveys &lt;- read.csv(&#x27;svy_complete.csv&#x27;)<br>&nbsp;<br>&nbsp;if (conditional statement) {<br>&nbsp;&nbsp;&nbsp;&nbsp; action<br>&nbsp;&nbsp;&nbsp; } else { do this other thing<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>if (surveys$year[1]==1984) {<br>&nbsp; print(&quot;Great Scott, it&#x27;s 1984!&quot;)<br>&nbsp; } else {<br>&nbsp; print(&quot;it&#x27;s not 1984&quot;)<br>&nbsp; }<br>&nbsp;<br>&nbsp;<br>Challenge<br>Let&#8217;s say we&#8217;re interested in knowing whether an animal is large or not, with a cut-off of at least one ounce. Write an if&#x2F;else statement that evaluates whether the first animal in our data is larger than an ounce. (Hint: one ounce is 28.3g)<br>&nbsp;<br>&nbsp;if (surveys$weight[1] &gt; 28.3) {<br>&nbsp;&nbsp;&nbsp;&nbsp; print(&quot;the first animal weighs more than one ounce&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp; print(&quot;nope, too tiny.&quot; )<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>But this only works on the first row.&nbsp; We want to do it on all rows.&nbsp;<br><br>Loops<br><br>General syntax:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>for (variable in vector) {<br>&nbsp; do something}<br>&nbsp;&nbsp;<br>a simple loop :<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>for (i in 1:10) {<br>&nbsp; print (i)<br>&nbsp; }<br>&nbsp;&nbsp;<br>&nbsp;# You can put if statements inside for-loops!<br>&nbsp;&nbsp;<br>for (i in 1:dim(surveys)[1]) {<br>&nbsp; if (surveys$year[i]==1984) {<br>&nbsp;&nbsp;&nbsp; print(&quot;Great Scott, it&#x27;s 1984!&quot;)<br>&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; print(&quot;it&#x27;s not 1984&quot;)<br>&nbsp; }<br>}<br><br>#Save a copy of surveys in case we mess it up!<br>surveys_adjusted &lt;- surveys<br><br><br>#Let&#8217;s say that we discover from our collaborator that there was an issue in 1984. All of the scales had not been calibrated, and we need to increase the weights of any measurements made in that year by 10%. How can we go through and update our table?<br><br># We dont&#x27; need the else since we&#x27;re not going to adjust the non-1984 values.&nbsp;<br><br>for (i in 1:dim(surveys)[1]) {<br>&nbsp; if (surveys$year[i]==1984) {<br>&nbsp;&nbsp; surveys_adjusted$weight[i] &lt;- surveys$weight[i]*1.1<br>&nbsp; }&nbsp;<br>&nbsp; }<br>}<br><br>#Check that this worked:&nbsp;<br><br>&nbsp; surveys %&gt;%<br>&nbsp;&nbsp;&nbsp; group_by(year) %&gt;%<br>&nbsp;&nbsp;&nbsp; summarize(mean_weight=mean(weight))<br><br>&nbsp; surveys_adjusted %&gt;%<br>&nbsp;&nbsp;&nbsp; group_by(year) %&gt;%<br>&nbsp;&nbsp;&nbsp; summarize(mean_weight=mean(weight))<br><br><br>Challenges:<br><ol class="number"><li>Using a for loop, using an if&#x2F;else statement, and without using dplyr, tally the number of animals that weigh over an ounce in our dataset.</li><ol class="number"><li>to tally: initialize a variable, and in the loop, add one each time:&nbsp;</li><li>var &lt;-0</li><li>var &lt;-var+1</li><li><br></li><li>skinnyM &lt;-0</li><li>skinnyF &lt;-0</li><li>largeA &lt;-0</li><li>for (j in 1:dim(surveys)[1]) {</li><li>&nbsp; if (surveys$weight[j] &gt; 28.3) {</li><li>&nbsp;&nbsp;&nbsp; largeA &lt;- largeA + 1</li><li>&nbsp; } else {</li><li>}</li><li><br></li><li><br></li></ol><li>For the animals that are not over an ounce in weight, how many of them are female and how many of them are male?</li></ol><br>skinnyM &lt;-0<br>skinnyF &lt;-0<br>largeA &lt;-0<br>for (j in 1:dim(surveys)[1]) {<br>&nbsp; if (surveys$weight[j] &gt; 28.3) {<br>&nbsp;&nbsp;&nbsp; largeA &lt;- largeA + 1<br>&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; if (surveys$sex[j] == &quot;M&quot;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skinnyM &lt;- skinnyM + 1<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skinnyF &lt;- skinnyF +1<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}<br><br>Discussion on nice formatting of code (indenting in particular).&nbsp; It looks better in RStudio than in this notepad because R studio automatically suggests spacing and indenting<br><br><br># Functions<br>If you have to do anything more than once, put it in a function.&nbsp;<br><br><br>Our collaborator has noticed more problems with the data. They were wrong about the calibration issues in 1984, and have told us to discard the updated table we made. However, they realize that the person who recorded the data in 1984 somehow transformed all of the data they collected - both the weights and the hindfoot_length. To get the correct values, we will need multiply the recorded values by 1.1245697375083747 and add 10 to both of those variables. Your collaborator is very insistant that you use all of the significant digits provided when you convert values!<br><br>Could do this with loops<br><br>for (i in 1:dim(surveys_adjusted)[1]) {<br>&nbsp;&nbsp;&nbsp; if (surveys_adjusted$year[i] == 1984) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surveys_adjusted$weight[i] &lt;- surveys$weight[i]*1.1245697375083747+10<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surveys_adjusted$hindfoot_length[i] &lt;- surveys$hindfoot_length[i]*1.12456973750<strong>9</strong>3747+10<br>&nbsp;&nbsp;&nbsp; } }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>BUT!&nbsp; There is a typo in this crazy number.&nbsp; When making the adjustment more than once, you can make things more consistent with a function<br><br>general syntax:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>function_name &lt;- function(arguments) {<br>&nbsp;&nbsp;&nbsp; do stuff<br>}<br><br><br>convert_1984 &lt;- function(myval) {<br>&nbsp; myval_adjusted &lt;- myval*1.1245697375083747+10<br>}<br><br>convert_1984(1)<br><br># if we put a &quot;1&quot; into parentheses, the function will use the value 1 for myval, and apply the changes to that and return that value.&nbsp;<br><br><br># Now, let&#8217;s use this function in our loop to alter the values of weight and hindfoot_length:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>for (i in 1:dim(surveys_adjusted)[1]) {<br>&nbsp;&nbsp;&nbsp; if (surveys_adjusted$year[i] == 1984) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surveys_adjusted$weight[i] &lt;- convert_1984(surveys$weight[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surveys_adjusted$hindfoot_length[i] &lt;- convert_1984(surveys$hindfoot_length[i])<br>&nbsp;&nbsp;&nbsp; } }<br><br>#Challenge<br>Your collaborator tells you that you can use the length of the hindfoot to calculate brain volume. Apparently the hindfoot of these creatures is equal to the diameter of their skulls. Write a function that will calculate the volume of the animals skulls and apply it to this dataset. Hint: the volume of a sphere is 4&#x2F;3 * pi * r^3<br><br>lengthToVolume&lt;- function(len){<br>&nbsp; return(4&#x2F;3 * pi * len^3)<br>}<br><br><br>for (i in 1:dim(surveys_adjusted)[1]) {<br>&nbsp; print(lengthToVolume(surveys_adjusted$hindfoot_length[i]))<br>}<br><br><br>How would you save the results to a file instead of printing to screen?<br><br><br><br></body>
</html>
